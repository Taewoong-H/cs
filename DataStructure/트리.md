# Tree

트리는 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계(Hierarchical Relationship)을 표현하는 자료구조이다. 이 **트리**라는 자료구조는 표현에 집중한다. 무엇인가를 저장하고 꺼내야 한다는 사고에서 벗어나 트리라는 자료구조를 바라보자.
</br>
**트리를 구성하고 있는 구성요소들(요소)**
</br>

- Node(노드): 트리를 구성하고 있는 각각의 요소를 의미한다.
- Edge(간선): 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
- Root Node(루트 노드): 트리 구조에서 최상위에 있는 노드를 의미한다.
- Terminal Node(= leaf Node, 단말 노드): 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
- Internal Node(내부노드, 비단말 노드): 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.
  </br>

### Binary Tree(이진트리)

Binary Tree는 Root 노드를 포함, Leaf 노드를 제외한 모든 노드의 자식이 두 개인 것을 말한다. 공집합 역시 노드로 인정한다. 노드로 이루어진 각 층을 `Level`이라 하며 Level의 수를 이 트리의 `height`라 한다.

이진트리에는 모든 Level이 가득 찬 이진 트리인 **Full Binary Tree(포화 이진 트리)**와 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 채워진 트리인 **Complete Binary Tree(완전 이진 트리)**가 있다. 배열로 포화 이진트리와 완전 이진트리를 구현했을 때, 노드의 개수 n에 대해서 i번째 노드에 대해서 `parent(i) = i/2, left_child = 2i, right_child = 2i + 1`의 인덱스 값을 갖는다.
</br>

### BST, Binary Search Tree(이진 탐색 트리)

자료구조에서 효율적인 탐색 방법만을 고민할 것이 아니라, 효율적인 저장방법도 고민해야 한다. Binary Search Tree(이진 탐색 트리)는 이진 트리이며, 데이터를 저장하는 특별한 규칙이 있다. 그 규칙으로 찾고자 하는 데이터를 찾을 수 있다.

    1. 이진 탐색 노드에 저장된 값은 유일한 값이다.
    2. 루트 노드의 값은 왼쪽에 있는 모든 노드의 값보다 크다.
    3. 루트 노드의 값은 오른쪽에 있는 모든 노드의 값보다 작다.
    4. 각 서브 트리별로 2, 3번 규칙을 만족한다.

저장할 때 위의 규칙대로 잘 저장하기만 하면, 루트 노드로부터 원하는 값을 찾아나가는 것은 어렵지 않을 것이다. 하지만 값이 추가되고 삭제됨에 따라, 한 쪽에만 치우친 Skewed Tree(편향 트리)가 될 가능성이 있다. 이를 해결하기 위해 `Rebalancing`이라는 기법을 사용하여 트리를 재조정하게 된다.
</br>

### Red Black Tree

RBT(Red-Black Tree)는 위에서 설명한 `Rebalancing`기법의 하나로, 기존 이진탐색트리의 삽입, 삭제, 탐색의 비효율성을 개선한 방법이다. RBT는 다음과 같은 규칙을 따른다.

1. 각 노드는 `Red` 혹은 `Black`이라는 색깔을 갖는다.
2. 루트 노드는 `Black`이다.
3. 각 말단 노드(NIL)는 `Black`이다.
4. 어떤 노드의 색이 `Red`라면, 두 자식 노드의 색은 모두 `Black`이다.
5. 어느 한 노드로부터 리프노드(NIL)까지의 `Black`의 수는 리프노드를 제외하면 모두 같다(이를 `Black-Height`라 한다).

RBT 특징으로는 다음과 같다.

1. Binary Search Tree이므로, BST의 특징을 모두 갖고있다.
2. 루트로부터 말단 노드까지의 최소 경로는 최대 경로의 두 배보다 크지 않다. 이를 `Balanced`한 상태라 한다.
3. 노드의 Child가 없을 경우, Child를 가리키는 포인터에 NIL(혹은 NULL)값을 저장한다. 이러한 NIL 노드들을 말단 노드로 간주한다. 말단 노드이기 때문에, 이 노드들의 색은 `Black`이다.

RBT에서의 삽입 과정은 다음과 같다.
우선 새로 삽입한 노드를 BST 특성을 유지하며 삽입한 후, 색을 `Red`로 칠한다. 이는 `Black-Height`의 수를 최대한 유지하기 위해서이다. 삽입 결과 RBT 특성이 위배된다면, 노드의 색을 다시 칠한다. 만일 `Black-Height` 특성, 즉 위의 5번 규칙이 위배되었다면, `Rotation`을 통해 조정한다.

삭제 과정 역시 마찬가지로 우선 BST 특성을 유지하며 노드를 삭제한다. 삭제될 노드의 Child와 색깔로 `Rotation` 방법이 정해진다
</br>

### Binary Heap

자료구조의 일종으로 Tree의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 `Complete Binary Tree`이다. 배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 index 부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다. `힙(Heap)`에는 `최대힙(max heap)`, `최소힙(min heap)` 두 종류가 있다.

`Max Heap`에서는 Root node에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 time complexity 이 O(1)이다. 그리고 `complete binary tree`이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다. (즉, random access가 가능하다. Min heap에서는 최소값을 찾는데 소요되는 연산의 time complexity 가 O(1)이다.) 하지만 heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.
